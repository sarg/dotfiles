#+OPTIONS: num:nil
#+SETUPFILE: ~/devel/ext/org-html-themes/org/theme-readtheorg-local.setup
#+PROPERTY: header-args:scheme :tangle no :exports none :noweb-ref guix-pkg
#+begin_src elisp :exports none
;; -*- lexical-binding: t; -*-
;; generated from config.org
#+end_src
#+begin_src elisp :tangle packages.el :exports none
;; generated from config.org
#+end_src
* guix
To define guix dependencies add a =scheme= source code block. It'll be then tangled to =~/.dotfiles/guix/emacs-packages.scm= and merged with the main =home-environment=.

#+begin_src scheme :noweb yes :noweb-ref nil :tangle ~/.dotfiles/guix/emacs-home.scm
;; generated from config.org
(use-modules
 (gnu packages)
 (gnu home))
(home-environment
 (services (list
            <<guix-srv>>))
 (packages
  (map (compose list specification->package+output)
       '(
         <<guix-pkg>>))))
#+end_src
* guix-emacs helper
#+begin_src elisp
(defun use-guix-package (pkg-name)
  (interactive "MPackage: ")

  (let* ((pkg-path
          (thread-last
            pkg-name
            (format "(guix-command-output %S %S)" "build")
            (guix-eval-read)
            (s-trim)))

         (lisp-dir (car (directory-files
                         (concat pkg-path "/share/emacs/site-lisp")
                         'full (rx (not ?.))))))

    (add-to-list 'load-path lisp-dir)
    (require (intern (substring pkg-name 6)))))

(defun guix-package-info-insert-emacs-install-button (id name)
  "Insert install button for ENTRY if it is an emacs package."
  (when-let* ((is-emacs (string-prefix-p "emacs-" name)))
    (bui-insert-action-button
     "Use"
     (lambda (btn)
       (let ((name (car (split-string (button-get btn 'package-name) "@"))))
         (message "Use %s" name)
         (use-guix-package name)))
     "Use it without installing"
     'package-name name)))

(after! guix-ui-package
  (add-to-list 'guix-package-info-button-functions
               'guix-package-info-insert-emacs-install-button
               'append))
#+end_src
* guix development
#+begin_src scheme
"emacs-debbugs" "gnu-standards" "mumi-with-jaro"
#+end_src
#+begin_src elisp :tangle packages.el
(package! guix :built-in t)
#+end_src
#+begin_src elisp
(after! debbugs
  (setq debbugs-gnu-default-packages '("guix" "guix-patches"))
  (set-popup-rule! "^\\*Guix-Patches Bugs\\*$" :ignore t)
  (set-popup-rule! "^\\*Summary nndoc" :ignore t)
  (set-popup-rule! "^\\*Article" :ignore t))

(use-package! guix
  :config
  (setq guix-repl-use-server nil
        guix-current-profile "~/.guix-home/profile"
        guix-load-path '("/home/sarg/devel/dotfiles/guix/personal" "/home/sarg/devel/ext/nonguix")))
#+end_src
* doom
** base packages
#+begin_src scheme
"emacs-next"
"emacs-telega" "emacs-telega-contrib"
"emacs-vterm" "guix-icons"

; modules dependencies
"shfmt" "shellcheck" "fd"

; dirvish
"ffmpegthumbnailer" "poppler" "mediainfo" "vips"
#+end_src
#+begin_src scheme :noweb-ref guix-srv
(simple-service 'doom-vars home-environment-variables-service-type
  `(("DOOMLOCALDIR" . "$HOME/.local/doom/")
    ("DOOMDIR" . "$HOME/.dotfiles/emacs/.doom.d/")
    ("VISUAL" . "emacsclient")
    ("EDITOR" . "emacsclient")))
#+end_src
** init.el
#+begin_src elisp :tangle init.el
;; generated from config.org
(setq doom-leader-key "<f13>"
      doom-leader-alt-key "<f13>")
(doom!
 :completion  corfu vertico ;(ivy +fuzzy +prescient +childframe)
 :ui          nav-flash (modeline +light) ophints (popup +defaults) ligatures treemacs doom-dashboard
 :editor      (evil +everywhere) fold lispy snippets (format +onsave) multiple-cursors word-wrap
 :emacs       (dired +dirvish +icons) electric vc ibuffer undo
 :term        eshell vterm
 :tools       editorconfig (eval +overlay) (lookup +docsets) magit pdf (pass +auth) make tree-sitter lsp direnv llm
 :checkers    syntax
 :lang        clojure data emacs-lisp
              (org +contacts +dragndrop +pandoc +present +hugo +roam2 +pretty) beancount
              rest sh plantuml (python +pyenv +lsp) (web +html) yaml json
 :app         calendar telega (rss +org) torrent irc exwm emms dash-menu
 :email       (mu4e +gmail)
 :config      (default +bindings +smartparens +gnupg) literate)
#+end_src
** dashboard
#+begin_src elisp
(setq fancy-splash-image "~/.guix-home/profile/share/icons/hicolor/scalable/apps/guix-icon.svg")
(setq +doom-dashboard-functions
      '(doom-dashboard-widget-banner
        doom-dashboard-widget-shortmenu))
#+end_src
** modeline
#+begin_src elisp
(setq! +modeline-encoding nil
       +modeline-height 20)

(def-modeline! :main
  '(" " +modeline-buffer-identification) `(""))
(set-modeline! :main 'default)

(def-modeline! 'project
  `(" " (:eval (abbreviate-file-name default-directory))) '(""))
#+end_src
** override popup params
#+begin_src shell
(setq +popup--display-buffer-alist
      (seq-remove
       (lambda (el) (and (stringp (car el)) (string= (car el) "^\\*info\\*$")))
       +popup--display-buffer-alist))

(set-popup-rule!
 "^\\*info\\*$"
 :slot 2 :vslot 2 :size 0.45 :select t :quit nil :ttl nil)
#+end_src
* exwm
EXWM has a separate [[../.doom.d/modules/app/exwm][doom app]]. Here are just the settings.
#+begin_src scheme
"emacs-exwm"
"emacs-exwm-ss"
"emacs-ednc"
#+end_src
#+begin_src elisp :noweb yes :noweb-prefix no
(defun exwm-autostart-apps ()
    (interactive)
    (cl-loop
     for cmd in (list
                 <<autostart>>
                 )
     do (start-process-shell-command "autostart" "*autostart*" cmd)))

(after! exwm
  <<exwm>>
  (add-hook! exwm-init #'exwm-autostart-apps))
#+end_src
** notifications
#+begin_src elisp
(use-package! ednc
  :hook (exwm-init . ednc-mode)

  :config
  ; https://github.com/hiecaq/guix-config/blob/666d15b1f79b2b9171c430c24b877879ab61fd02/readme.org#desktop-notification-daemon
  (defvar my-ednc-posframe--buffer "*ednc-posframe*"
    "Buffer used for ednc notification posframe display.")

  (defun my-ednc-posframe-show ()
    (interactive)
    (when (and (buffer-live-p (get-buffer my-ednc-posframe--buffer))
               (posframe-workable-p))
      (posframe-show my-ednc-posframe--buffer
                     :poshandler #'posframe-poshandler-frame-top-right-corner
                     :border-width 1)))

  (defun my-ednc-posframe-hide ()
    (interactive)
    (when (posframe-workable-p)
      (posframe-hide my-ednc-posframe--buffer)))

  (defun my-ednc-posframe--update (&rest _)
    (let ((notifications (ednc-notifications)))
      (with-current-buffer (get-buffer-create my-ednc-posframe--buffer)
        (erase-buffer)
        (insert (mapconcat
                 (lambda (n) (ednc-format-notification n :expand))
                 notifications "")))
      (when (posframe-workable-p)
        (if notifications
            (my-ednc-posframe-show)
          (my-ednc-posframe-hide)))))

  (defun my-ednc--dismiss-first-notification ()
    (when-let* ((buffer (get-buffer my-ednc-posframe--buffer))
                (frame (with-current-buffer buffer
                         posframe--frame))
                ((frame-visible-p frame))
                (notification (ednc-notifications)))
      (ednc-dismiss-notification (car notification))))

  (advice-add #'keyboard-quit :before #'my-ednc--dismiss-first-notification)
  (add-hook 'ednc-notification-presentation-functions #'my-ednc-posframe--update))
#+end_src
** bar
#+begin_src elisp
(setq!
 battery-mode-line-format " %b%>2p% "
 battery-mode-line-limit 50
 display-time-string-forms '((substring (format-time-string "%a") 0 1)
                              (format-time-string "%d %R")))

(display-battery-mode 1)
(display-time-mode 1)
#+end_src
** workspaces
#+begin_src elisp :noweb-ref exwm :tangle no
(tab-rename "code" 1)
(progn (tab-new) (tab-rename "brow" 2))
(progn (tab-new) (tab-rename "dash" 3))
(tab-bar-mode 1)

(exwm/bind-command
 "<f13> 1" (lambda () (interactive) (tab-bar-switch-to-tab "code"))
 "<f13> 2" (lambda () (interactive) (tab-bar-switch-to-tab "brow")))

(custom-set-faces!
  '(tab-bar-tab :weight bold)
  '(tab-bar-tab-inactive :weight normal))

(setq!
 tab-bar-auto-width nil
 tab-bar-select-restore-windows nil
 tab-bar-new-tab-choice "*scratch*"
 tab-bar-format '(tab-bar-format-tabs
                  tab-bar-separator
                  tab-bar-format-align-right
                  tab-bar-format-global))
#+end_src
** per-app settings
#+begin_src elisp :noweb-ref exwm :tangle no
(setopt exwm-manage-configurations
        `(((-any? (lambda (el) (equal exwm-class-name el))
            '("mpv" "scrcpy" "AusweisApp2" "iwgtk"))
           floating t
           floating-mode-line nil)
          ((equal exwm-class-name "Spotify")
           dont-steal-focus t)
          ((equal exwm-class-name "Pavucontrol")
           floating t
           floating-mode-line nil
           width 560
           height 400)))
#+end_src
** bindings
*** simulation
When this key event occurs, replace it with another.
#+begin_src elisp :noweb-ref exwm :tangle no
(setq exwm-input-simulation-keys
      `((,(kbd "C-m") . return)
        (,(kbd "DEL") . backspace)

        ; key h in ru layout
        (,(kbd "C-р") . backspace)))
#+end_src
*** floating
As I've remapped =LWIN= to =F13=, I've lost the floating window resize/move bindings.
Let's restore them with =Ctrl= instead of =Super=.
#+begin_src elisp :noweb-ref exwm :tangle no
(setq exwm-input-resize-event 'C-down-mouse-3
      exwm-input-move-event 'C-down-mouse-1)
#+end_src
*** prefix
These are not full bindings, but the first keys in some sequence. Tell EXWM to
send these events to emacs.
#+begin_src elisp :noweb-ref exwm :tangle no
(setq exwm-input-prefix-keys
      `([f13]
        ?\C-w ?\C-x ?\M-x ?\M-m ?\C-g
        ?\C-m ?\C-h

        ;; cyrillic
        ?\C-р))
#+end_src
*** x11-only
These are bound only for X11 apps.
#+begin_src elisp :noweb-ref exwm :tangle no
(define-key! exwm-mode-map
  ;; consistent layout switch binding
  [?\C-\\] 'exwm-xkb-next-layout

  ;; this undoes exwm-input-prefix-keys for the next keypress
  [?\C-q] 'exwm-input-send-next-key

  ;; remove the default EXWM bindings
  [?\C-c] 'nil)
#+end_src
#+begin_src elisp :noweb-ref exwm :tangle no
(add-hook! 'exwm-input-input-mode-change-hook
  (defun exwm/enable-xkb-layout-switch ()
    (start-process "keymap.sh" nil "keymap.sh"
                   (if (eq exwm--input-mode 'char-mode) "enable" "disable"))))
#+end_src
*** global
#+begin_src elisp :noweb-ref exwm :tangle no
(defun exwm/switch-to-next-buffer (class &optional reverse?)
  "Form a cycle of CLASS buffers and return the one next to current buffer.
REVERSE? it when true. Returns the selected buffer."
  (cl-loop
    with first with this with next
    for b in (if reverse? (reverse (buffer-list)) (buffer-list))
    when (string= class (buffer-local-value 'exwm-class-name b)) do
      (setf first (or first b))
      (setf next (and this b))
      (setf this (or this (when (eq (current-buffer) b) b)))
    until next
    finally return
    (and (or next first)
         (switch-to-buffer (or next first) t t))))

(exwm/bind-command
 "<f13> r"     #'app-launcher-run-app

 "<f13> h"     #'evil-window-left
 "<f13> j"     #'evil-window-down
 "<f13> k"     #'evil-window-up
 "<f13> l"     #'evil-window-right

 "<f13> E"    `(lambda () (interactive)
                 (tab-switch "brow")
                 (cond
                  ((string= "qutebrowser" exwm-class-name)
                   (exwm/switch-to-next-buffer "qutebrowser" 'reverse))

                  ((not (get-process "qutebrowser"))
                   (start-process "qutebrowser" nil "setsid" "-w" "qutebrowser"))))

 "<f13> e"    `(lambda () (interactive)
                 (tab-switch "brow")
                 (or (exwm/switch-to-next-buffer "qutebrowser")
                     (start-process "qutebrowser" nil "setsid" "-w" "qutebrowser"))))
#+end_src
** app launcher
#+begin_src scheme
"dex"
#+end_src
#+begin_src elisp
;; the default one messes up exec path of wine programs due to wrong parsing
(after! app-launcher
  (defun app-launcher--action-dex (selected)
    (call-process "dex" nil nil nil (alist-get 'file selected)))

  (defvar app-launcher-allow-list
    '("lutris" "libreoffice-startcenter" "flatseal" "spotify" "calibre-gui" "idea" "simple-scan"
      "iwgtk" "android")
    "Apps that are visible in the app-launcher")

  (defvar app-launcher-hide-list
    '("flatpak" "emacs" "qview" "scrcpy" "qutebrowser" "darkman"
      "libreoffice" "mpv" "quake3" "flameshot" "calibre")
    "Apps to hide from the app-launcher")

  (defun app-launcher-filter (apps)
    (maphash (lambda (_ def)
               (let ((file (alist-get 'file def)))
                 (unless (or
                          (-any? (lambda (i) (s-contains? i file t)) app-launcher-allow-list)
                          (-none? (lambda (i) (s-contains? i file t)) app-launcher-hide-list))
                   (setf (alist-get 'visible def) nil))))
             apps)
    apps)

  (advice-add 'app-launcher-parse-files
              :filter-return #'app-launcher-filter)

  (defvar app-launcher--M-x-set '())
  (defun app-launcher-to-M-x ()
    (interactive)

    ; forget previously set functions
    (-each app-launcher--M-x-set #'fmakunbound)
    (setq app-launcher--M-x-set '())

    ; create new functions
    (maphash
     (lambda (name app)
       (when (cdr (assq 'visible app))
         (let ((app-symbol (intern (concat "app-" (s-dashed-words name)))))
           (push app-symbol app-launcher--M-x-set)
           (fset app-symbol
                 (lambda ()
                   (interactive)
                   (funcall app-launcher-action-function app)))
           (put app-symbol 'function-documentation (cdr (assq 'comment app))))))
     (app-launcher-list-apps)))

  (app-launcher-to-M-x)
  (setq app-launcher--action-function #'app-launcher--action-dex))
#+end_src
* completion
#+begin_src elisp
; have no use for vertico-next-group
(after! consult
  (define-key consult-async-map [remap vertico-insert] nil))
#+end_src
* TODO fix waiting for upstream
#+begin_src elisp :noweb-ref exwm :tangle no
; https://github.com/emacs-exwm/exwm/pull/85
(defun sarg/exwm--on-net-active-window (id _data)
  "Handle _NET_ACTIVE_WINDOW message with ID."
  (let ((buffer (exwm--id->buffer id))
        window)
    (if (buffer-live-p buffer)
        ;; Either an `exwm-mode' buffer (an X window) or a floating frame.
        (with-current-buffer buffer
          (when (and (eq exwm--frame exwm-workspace--current)
                     (not (plist-get exwm--configurations 'dont-steal-focus)))
            (if exwm--floating-frame
                (select-frame exwm--floating-frame)
              (setq window (get-buffer-window nil t))
              (unless window
                ;; State change: iconic => normal.
                (setq window (frame-selected-window exwm--frame))
                (set-window-buffer window (current-buffer)))
              ;; Focus transfer.
              (select-window window))))
      ;; A workspace.
      (dolist (f exwm-workspace--list)
        (when (eq id (frame-parameter f 'exwm-outer-id))
          (x-focus-frame f t))))))

(advice-add 'exwm--on-net-active-window :override #'sarg/exwm--on-net-active-window)
#+end_src
* theme
#+begin_src scheme
"emacs-catppuccin-theme"
#+end_src
#+begin_src elisp :tangle packages.el :exports none
(package! greymatters-theme :pin "a7220a8c6cf18ccae2b76946b6f01188a7c9d5d1")
(package! catppuccin-theme :built-in t)
#+end_src

#+begin_src elisp
(use-package! greymatters-theme)
(use-package! catppuccin-theme)
(defvar doom-theme-dark 'catppuccin)
(setq doom-theme 'greymatters
      doom-font (font-spec :family "Hack" :size 18)
      doom-serif-font (font-spec :family "Hack")
      doom-symbol-font (font-spec :family "Hack"))
#+end_src

Note: use =consult-theme= to quickly preview themes.
[[*dark mode][see: dark mode]]
* flatpaks
#+NAME: flatpak-list
#+begin_src sh :tangle no :results output
flatpak list --app --columns=application | head -n -1
#+end_src

#+RESULTS: flatpak-list
#+begin_example
com.endlessnetwork.aqueducts
com.github.tchx84.Flatseal
com.google.AndroidStudio
com.jetbrains.IntelliJ-IDEA-Community
com.spotify.Client
de.blobbyvolley.BlobbyVolley2
io.sourceforge.zaz
net.lutris.Lutris
net.sourceforge.lgames.LBreakoutHD
org.mattdm.icebreaker
org.prismlauncher.PrismLauncher
org.regular_dev.biplanes_revival
org.sugarlabs.MakeThemFall
#+end_example

#+begin_src sh :tangle no :stdin flatpak-list
xargs flatpak install --or-update --noninteractive
#+end_src
* desktop
** desktop entries
#+begin_src scheme
"jaro"
#+end_src
#+begin_src scheme :tangle ~/.config/associations :noweb-ref nil
(bind
 #:pattern "^mailto:.*"
 #:program '(emacsclient --eval "(message-mailto \"%f\")"))

(bind
 #:pattern "^https://t.me/.*"
 #:program '(emacsclient --eval "(telega-browse-url \"%f\")"))

(bind
 #:pattern "^org-protocol:.*"
 #:program '(emacsclient %f))

(bind
 #:pattern '("(application|text)/(x-)?(pdf|postscript|ps|epub.*)" "image/(x-)?eps" "image/vnd.djvu")
 #:program '(zathura %f))

(bind
 #:pattern "^video/.*"
 #:program '(mpv %f))

(bind
 #:pattern "^https?://"
 #:program '(qutebrowser %f))

(bind
 #:pattern "^image/.*"
 #:program '(qview %f))
#+end_src
** multimedia keys
#+begin_src elisp :noweb-ref exwm :tangle no
(exwm/bind-command
   "<XF86Launch1>" #'dash-menu
   "<XF86MonBrightnessUp>" "brightnessctl -e set 10%+"
   "<XF86MonBrightnessDown>" "brightnessctl -e set 10%-"
   "<XF86ScreenSaver>" "xset s activate"
   "<f13> <f12>" "flameshot gui")
#+end_src
** dark mode
#+begin_src scheme
"darkman"
"redshift"
#+end_src
#+begin_src elisp :tangle packages.el :exports none
(package! darkman)
(package! solar :built-in t)
#+end_src
#+begin_src yaml :tangle ~/.config/darkman/config.yaml
lat: 52.52
lng: 13.39
dbusserver: true
#+end_src
#+begin_src elisp
;; Change color theme based on day time
(use-package! solar
  :custom
  (calendar-latitude 52.52)
  (calendar-longitude 13.39))

(use-package! darkman
  :custom
  (darkman-themes `(:light ,doom-theme
                    :dark ,doom-theme-dark))
  :config
  (defadvice load-theme (before no-theme-stacking activate)
    "Disable the previous theme before loading a new one."
    (mapc #'disable-theme custom-enabled-themes))

  (if (display-graphic-p)
      (add-hook! 'after-init-hook (darkman-mode))))

(defvar sarg-redshift-timer 'nil
  "Stores redshift-adjust timer")

(defun sarg/redshift-adjust ()
  (interactive)
  (start-process-shell-command
   "redshift" nil
   (format "redshift -m randr -Po -l %f:%f" calendar-latitude calendar-longitude)))

(defun sarg/redshift-start ()
  (interactive)
  (unless sarg-redshift-timer
    (setq sarg-redshift-timer (run-at-time nil 60 #'sarg/redshift-adjust))))

(defun sarg/redshift-cancel ()
  (interactive)
  (when sarg-redshift-timer (cancel-timer sarg-redshift-timer))
  (start-process-shell-command "redshift" nil "redshift -x"))

(add-hook! exwm-init #'sarg/redshift-start)
#+end_src
** bluetooth
#+begin_src scheme
"emacs-bluetooth"
#+end_src
#+begin_src elisp :tangle packages.el
(package! bluetooth :built-in t)
#+end_src
#+begin_src elisp
(use-package! bluetooth)
#+end_src
** udisks
#+begin_src scheme
"emacs-discomfort"
#+end_src
#+begin_src elisp :tangle packages.el
(package! discomfort :built-in t)
#+end_src
#+begin_src elisp
(use-package! discomfort
  :config
  (add-to-list 'evil-emacs-state-modes 'discomfort-mode)
  (define-key! discomfort-mode-map
    "j" #'next-line
    "k" #'previous-line))
#+end_src
* gpg
#+begin_src scheme
"emacs-pinentry" "gnupg"
#+end_src
#+begin_src scheme :noweb-ref guix-srv
(service home-gpg-agent-service-type
 (home-gpg-agent-configuration
  (pinentry-program
   (file-append pinentry-emacs "/bin/pinentry-emacs"))
  (ssh-support? #t)
  (default-cache-ttl 86400)
  (max-cache-ttl 86400)
  (default-cache-ttl-ssh 86400)
  (max-cache-ttl-ssh 86400)
  (extra-content "disable-scdaemon")))
#+end_src
#+begin_src elisp :tangle packages.el
(package! pinentry :built-in t)
#+end_src
#+begin_src elisp
(use-package! pinentry
  :config
  (pinentry-start))
#+end_src
* emacs screencast recording
#+begin_src elisp :tangle packages.el
(package! command-log-mode :pin "af600e6b4129c8115f464af576505ea8e789db27")
;(package! keycast)
;(package! camcorder) autoloads fail because of names.el usage. todo: debug
#+end_src

#+begin_src elisp
(use-package! command-log-mode
  :commands command-log-mode)
;; (use-package! camcorder
;;   :commands camcorder-mode
;;   :hook (camcorder-mode-hook . clm/command-log-clear))
#+end_src

#+begin_src scheme
"recordmydesktop"
#+end_src
* miscellaneous
#+begin_src elisp
;; C-h deletes character backwards
(define-key key-translation-map [?\C-h] [?\C-?])

(setq-default
 ;; russian layout on C-\
 default-input-method "russian-computer"

 ;; start scrolling when this far from the top or bottom of the buffer
 scroll-margin 15)
#+end_src

** Debug icons in modeline, find out their names. :noexport:
#+begin_src elisp :tangle no
(defadvice! +debug-modeline-format-icon (icon-set icon label &optional face &rest args)
  :override +modeline-format-icon
  (propertize (format "X %s" label) 'face face))
#+end_src
* buffers
#+begin_src elisp :tangle packages.el :exports none
(package! bufler :pin "b96822d2132fda6bd1dd86f017d7e76e3b990c82")
#+end_src

#+begin_src elisp
(use-package! bufler
  :init
  (set-popup-rule! "^\\*Bufler\\*$" :ignore t)

  :config
  (after! exwm
    (exwm-input-set-key (kbd "s-b") #'bufler-switch-buffer))

  (after! evil-collection
    (evil-collection-define-key 'normal 'bufler-list-mode-map
      (kbd "C-k") 'bufler-list-buffer-kill
      "r" 'bufler
      (kbd "RET") 'bufler-list-buffer-switch))

  :custom
  (bufler-groups
   (bufler-defgroups
     (group (mode-match "Telega" (rx bos "telega-chat")))
     (group
      (group-and "X11" (mode-match "exwm-mode" (rx bos "exwm-mode")))
      (group-and "WWW"
       (lambda (b) (string= "qutebrowser" (buffer-local-value 'exwm-class-name b)))))
     (group (auto-project))
     (auto-directory))))
#+end_src
* org mode
#+begin_src elisp :tangle packages.el
(package! org-modern-indent
    :recipe (:host github :repo "jdtsmith/org-modern-indent")
    :pin "9973bd3b91e4733a3edd1fca232208c837c05473")
(package! corg
  :recipe (:host github :repo "isamert/corg.el")
  :pin "79af293aa95936274d7b3a6ba13d4b66a3a6ee76")
(package! org-projectile :pin "bf1c30b750020ab8dd634dd66b2c7b76c56286c5")
(package! org-tidy :pin "0bea3a2ceaa999e0ad195ba525c5c1dcf5fba43b")
#+end_src
#+begin_src scheme
"font-iosevka-curly" ; for org-modern bullets
#+end_src

#+begin_src elisp
(setq
 org-directory (expand-file-name "~/Sync/org/")
 org-refile-targets `((nil :maxlevel . 3)
                      (,(expand-file-name "bookmarks.org" org-directory) :level . 1)
                      (org-agenda-files :maxlevel . 3))

 org-src-window-setup 'current-window
 org-fold-catch-invisible-edits 'show-and-error)

(use-package! org-checklist)
(use-package! org-projectile
  :config
  (setq org-project-capture-default-backend
        (make-instance 'org-project-capture-projectile-backend))
  (org-project-capture-per-project))

(use-package! corg
  :hook (org-mode . corg-setup))

(use-package! org-tidy
  :disabled
  :hook (org-mode . org-tidy-mode))

(use-package! org-contacts
  :custom
  (org-contacts-files (list (expand-file-name "contacts.org" org-directory))))

(use-package! org-modern-indent
  :hook (org-mode . org-modern-indent-mode))

(after! org-download
  (setq org-download-screenshot-method "flameshot gui --raw > %s"))

(load! "org-defuns")
#+end_src
** capture :noexport:
#+begin_src python :tangle ~/.local/share/qutebrowser/userscripts/orgprotocol :shebang #!/usr/bin/env python3
import os
from urllib.parse import quote
os.execlp('xdg-open', 'xdg-open',
          'org-protocol://capture?template=b&url={url}&title={title}&body={body}'.format(
              url   = quote(os.environ.get('QUTE_URL', '')),
              title = quote(os.environ.get('QUTE_TITLE', '')),
              body  = quote(os.environ.get('QUTE_SELECTED_TEXT', ''))))
#+end_src
#+begin_src elisp
(pushnew! org-capture-templates
          '("b" "Bookmark URL" entry
            (file+headline +org-capture-todo-file "Inbox")
            "* %?%a\n%i" :prepend t))
#+end_src
** agenda
#+begin_src elisp :tangle packages.el :exports none
(package! german-holidays :pin "a8462dffccaf2b665f2032e646b5370e993a386a")
#+end_src

#+begin_src elisp
(use-package! german-holidays
  :custom
  (calendar-holidays holiday-german-BE-holidays))

(setq
 org-agenda-files
 (-concat
  (org-project-capture-todo-files)
  (-map (lambda (el) (expand-file-name el org-directory))
        '("main.org"
          "tickler.org"))))
#+end_src

** roam
#+begin_src elisp
(after! org-roam
  (setq org-roam-db-node-include-function
        (lambda ()
          (not (member "ATTACH" (org-get-tags))))))
#+end_src
** elasticsearch :noexport:
#+begin_src elisp :tangle no
(package! es-mode :pin "e82465fd785688bb58918ea62ca4de06a2a23a1e")
#+end_src

#+begin_src elisp :tangle no
(use-package! es-mode
  :commands (org-babel-execute:es)

  :config
  (appendq!
   +org-babel-mode-alist '((es . elasticsearch))))
#+end_src
* programming
** vcs
#+begin_src elisp :tangle packages.el
(package! magit-todos :disable t) ; too slow
#+end_src

#+begin_src elisp
(after! magit
  (let ((sarg-repos-dir (expand-file-name "~/devel/")))
    (setq magit-repository-directories `((,sarg-repos-dir . 2))
          magit-clone-default-directory `,sarg-repos-dir)))

(after! browse-at-remote
  (setq browse-at-remote-prefer-symbolic nil))
#+end_src
** just
#+begin_src elisp :tangle packages.el
(package! just-mode)
#+end_src
#+begin_src elisp
(use-package! just-mode)
#+end_src

* tramp
#+begin_src elisp
(after! tramp
  (pushnew! tramp-remote-path 'tramp-own-remote-path))
#+end_src
* book reading
#+begin_src elisp
(use-package! zathura-sync-theme
  :config
  (zathura-sync-theme-mode))
#+end_src
#+begin_src text :tangle ~/.config/zathura/zathurarc
set guioptions ""
set statusbar-basename true
include theme
#+end_src
#+begin_src elisp :tangle packages.el
(package! calibredb :built-in t)
(package! nov :built-in t)
(package! zathura-sync-theme
  :recipe (:host github :repo "amolv06/zathura-sync-theme")
  :pin "7f1dece30d9f03e37d12ebfb3af6b1d663e4c8dd")
#+end_src

#+begin_src scheme
"emacs-calibredb" "sqlite" "emacs-nov-el" "emacs-pdf-tools"
#+end_src

#+begin_src elisp :tangle no
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)

  :custom
  (nov-variable-pitch nil)
  (nov-text-width t))
#+end_src

#+begin_src elisp
(use-package! calibredb
  :commands calibredb

  :custom
  (calibredb-root-dir (alist-get 'library_path (json-read-file "~/.config/calibre/global.py.json")))
  (calibredb-preferred-format 'epub) ;; just open it, don't ask

  ;; hide extra columns
  (calibredb-date-width 0)
  (calibredb-format-width 0)
  (calibredb-title-width 80)
  (calibredb-tag-width -1)
  (calibredb-comment-width 0)

  :config
  (defalias 'calibredb-open-with-default-tool #'find-file))
#+end_src

* password-store
#+begin_src elisp :tangle packages.el :exports none
(package! password-generator :built-in t)
(package! password-store :built-in t)
(package! password-store-otp :built-in t)
#+end_src
#+begin_src scheme
"password-store"
"pass-otp"
"emacs-password-generator"
"emacs-password-store"
"emacs-password-store-otp"
#+end_src

#+begin_src elisp
(after! auth-source
  (setq auth-sources '(password-store)))

(after! embark
  (defun password-store-otp-token-copy-and-echo (entry)
    "Copy an OTP token from ENTRY to clipboard."
    (interactive (list (read-string "Password entry: ")))
    (require 'password-store-otp)
    (let ((token (password-store-otp-token entry)))
      (message "OTP %s: %s" entry token)
      (password-store-otp--safe-copy token)))

  (defvar-keymap embark-pass-actions
    :doc "Keymap for actions for pass entries."
    :parent embark-general-map
    "f" #'password-store-copy-field
    "b" #'password-store-url
    "o" #'password-store-otp-token-copy-and-echo
    "e" #'password-store-edit
    "g" #'password-store-generate
    "r" #'password-store-rename
    "d" #'password-store-remove)


  (add-to-list 'embark-keymap-alist '(pass . embark-pass-actions)))
#+end_src

#+begin_src elisp
(setq password-cache-expiry (* 60 15))

;; for magithub auth to work create pass entry user^magithub@api.github.com
(after! magit
    (setq magit-process-find-password-functions '(magit-process-password-auth-source)))

(use-package! password-generator
  :after password-store

  :config
  (defadvice! +password-store-edit-locally (entry)
    :override #'password-store-edit
    (interactive (list (password-store--completing-read t)))
    (find-file (password-store--entry-to-file entry)))

  (defadvice! +password-store-generate-strong (entry &optional len)
    :override #'password-store-generate
    (interactive (list (password-store--completing-read)
                       (when current-prefix-arg
                         (abs (prefix-numeric-value current-prefix-arg)))))
    (let ((pass
           (password-generator-strong
            (or len password-store-password-length) t)))
      (password-store-insert entry pass))))
#+end_src

** qutebrowser integration
#+begin_src elisp
(defun qute/choose-pass (url)
   (completing-read "Pass: " (password-store-list) nil t url))
#+end_src

#+NAME: password_fill_rc
#+begin_src bash :tangle ~/.config/qutebrowser/password_fill_rc
choose_entry() {
    MENU_COMMAND=( dmenu -p pass -c pass )
    choose_entry_menu || true
}
#+end_src

* music
** emms
#+begin_src elisp
(defun dont-kill-buffer--hook ()
  (bury-buffer)
  (user-error "Don' kill me."))

(define-minor-mode dont-kill-buffer-mode
  "Don't kill buffer, just bury it."
  :global nil

  (if dont-kill-buffer-mode
      (add-hook 'kill-buffer-hook #'dont-kill-buffer--hook 0 t)
    (remove-hook 'kill-buffer-hook #'dont-kill-buffer--hook t)))

(defun =emms ()
  (interactive)
  (require 'emms)
  (cl-letf (((symbol-function 'switch-to-buffer) #'display-buffer))
    (if (or (null emms-playlist-buffer)
            (not (buffer-live-p emms-playlist-buffer)))
        (call-interactively 'emms-add-playlist))
    (emms)))

(after! emms
  (setq!
   emms-player-mpv-update-metadata t
   emms-playlist-buffer-name "*Music*"
   emms-source-file-default-directory (expand-file-name "~/Sync/"))

  (map! :map emms-playlist-mode-map
        :localleader
        "r" #'emms-toggle-random-playlist)

  (when (modulep! :app emms +history)
    (add-hook! emms-playlist-mode #'dont-kill-buffer-mode)
    (setq emms-history-file "/storage/data/emacs/emms_history")
    (emms-history-load))

  (setq emms-player-list (list emms-player-mpv)))
#+end_src
*** buffer and modeline
#+begin_src elisp
(after! emms
  (defun emms/modeline-status-icon ()
    (let ((clickable
           (lambda (text action)
             (propertize text 'keymap (make-mode-line-mouse-map 'mouse-1 action)))))
      (apply clickable
             (cond
              ((and emms-player-playing-p emms-player-paused-p)
               (list "" #'emms-pause))
              ((and emms-player-playing-p (emms-player-get 'emms-player-spotify 'ad-blocked))
               (list "" #'ignore))
              (emms-player-playing-p
               (list "" #'emms-pause))
              (t (list "" #'ignore))))))

  (set-popup-rule!
    (lambda (buffer action)
      (buffer-local-value 'emms-playlist-buffer-p (get-buffer buffer)))
    :ttl nil
    :quit 'current
    :select t
    :modeline '(" "
                (:eval (when emms-random-playlist " "))
                (:eval (emms/modeline-status-icon))
                emms-mode-line-string
                emms-playing-time-string)
    :height 15)

  (add-hook!
    (emms-player-paused emms-player-started emms-player-stopped) #'force-mode-line-update)

  ;; don't show mode-line globally, to be shown only in the popup buffer
  (emms-mode-line-mode 1)
  (setq emms-mode-line-mode-line-function #'emms-mode-line-playlist-current)
  (delq 'emms-mode-line-string global-mode-string)
  (delq 'emms-playing-time-string global-mode-string))
#+end_src
*** bindings
#+begin_src elisp :noweb-ref exwm :tangle no
(exwm/bind-command
 "<XF86AudioRaiseVolume>" #'emms-volume-raise
 "<XF86AudioLowerVolume>" #'emms-volume-lower
 "<XF86AudioMute>" "wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle"
 "<XF86AudioMicMute>" "wpctl set-mute @DEFAULT_AUDIO_SOURCE@ toggle")

(after! emms
  (exwm/bind-command
   "<XF86AudioPlay>" #'emms-pause
   "<XF86AudioPrev>" #'emms-previous
   "<XF86AudioNext>" (lambda () (interactive) (if emms-random-playlist (emms-random) (emms-next)))))
#+end_src
** spotify
*** player
#+begin_src elisp :tangle packages.el
(package! emms-player-spotify
  :recipe (:host github :repo "sarg/emms-spotify" :files (:defaults "contrib"))
  :pin "ca80431b00738e6130b924c64dc1f2cddadcc0b8")
#+end_src
#+begin_src elisp
(use-package! emms-player-spotify
  :after emms
  :load-path
  (lambda ()
    (list (concat doom-local-dir "straight/build-" emacs-version "/emms-player-spotify/contrib")
          (concat doom-local-dir "straight/build-" emacs-version "/emms-player-spotify")))

  :custom
  (emms-player-spotify-launch-cmd "flatpak run com.spotify.Client")
  (emms-player-spotify-adblock t)

  :config
  (setq emms-player-spotify-debug t)
  (add-to-list 'emms-player-list emms-player-spotify))
#+end_src
*** search
#+begin_src elisp :tangle packages.el
(package! counsel-spotify :pin "2743ad52a9def53534fd505397fbe1ac49e53015")
#+end_src
#+begin_src elisp
(use-package! counsel-spotify
  :after-call counsel-spotify-search-album
  :custom
  (counsel-spotify-use-notifications nil) ; conflicts with handlers of emms-player-spotify

  :config
  (require 'emms)
  (require 'emms-player-spotify-counsel)
  (defun counsel-spotify-verify-credentials ()
    (unless (auth-source-pass-get "client-id" "Sites/spotify.com")
      (error "Spotify pass not available")))

  (defun counsel-spotify-basic-auth-credentials ()
    (concat "Basic " (base64-encode-string
                      (concat
                       (auth-source-pass-get "client-id" "Sites/spotify.com")
                       ":"
                       (auth-source-pass-get "client-secret" "Sites/spotify.com"))
                      t))))
#+end_src
* elfeed
#+begin_src scheme
"emacs-elfeed-org"
#+end_src
#+begin_src elisp :tangle packages.el
(package! elfeed-org :built-in t)
#+end_src
#+begin_src elisp
(defun elfeed-open-special ()
  "Open videos directly."
  (interactive)
  (let ((entry (elfeed-search-selected :single)))
    (if (seq-contains-p (elfeed-entry-tags entry) 'youtube)
        (elfeed-search-browse-url)
      (elfeed-search-show-entry entry))))

(after! elfeed
  (setq elfeed-db-directory "/storage/data/elfeed")
  (add-hook 'elfeed-show-mode-hook (lambda () (setq-local browse-url-generic-program "qutebrowser-background")))

  (setq elfeed-search-filter "@2-week-ago +unread -youtube"
        elfeed-show-entry-switch #'display-buffer)

  (evil-define-key 'normal elfeed-search-mode-map
    (kbd "RET") #'elfeed-open-special
    "q" #'elfeed-search-quit-window))
#+end_src

#+begin_src sh :tangle ~/.local/bin/qutebrowser-background :shebang #!/bin/sh :exports none
qutebrowser --nowindow --target tab-bg-silent $@
#+end_src

* dict
[[https://github.com/BoboTiG/ebook-reader-dict][Wiktionary exports]]
#+begin_src scheme
"emacs-lexic" "sdcv" "emacs-google-translate"
#+end_src
#+begin_src elisp :tangle packages.el
(package! lexic :built-in t)
(package! dictcc :pin "30b505759e5a97c2aaa8b0e8ea5e187fdf625c65")
(package! powerthesaurus :pin "4b97797cf789aaba411c61a85fe23474ebc5bedc")
#+end_src
#+begin_src elisp
(defun lexic-format-shr (entry &optional _expected-word)
  (with-temp-buffer
    (insert (plist-get entry :info))
    (cl-letf* ((tree (libxml-parse-html-region))
               (dict (plist-get entry :dict))
               (orig (symbol-function 'shr-urlify))
               ((symbol-function 'shr-urlify)
                (lambda (start url &optional title)
                  (funcall orig start (concat url "?dict=" dict) title))))
      (erase-buffer)
      (shr-insert-document tree)
      (buffer-string))))

(use-package! lexic
  :config
  (set-lookup-handlers! 'lexic-mode
    :documentation #'lexic-search)
  (set-popup-rule!
    '(major-mode . lexic-mode)
    :ttl nil
    :side 'left
    :quit 'current
    :select t
    :width 60)

  (defun lexic-open-bword-link (link &rest _)
    (let* ((qmark (s-index-of "?dict=" link))
           (word (substring link 8 qmark))
           (dict (substring link (+ qmark 6))))
      (lexic-search word nil (list dict) 'interactive nil)))

  (add-to-list 'browse-url-handlers
               '("bword://" . lexic-open-bword-link))

  (map! :map lexic-mode-map
        :n
        "RET" #'lexic-search-word-at-point
        "," #'lexic-search-history-backwards
        "." #'lexic-search-history-forwards
        "a" #'outline-show-all
        "n" #'lexic-next-entry
        "p" #'lexic-previous-entry)

  (setq lexic-dictionary-specs
        '(("Wiktionary DE-DE" :short "Wiktionary" :formatter lexic-format-shr :priority 0)
          ("Duden - Das große Wörterbuch der deutschen Sprache"
           :short "Duden" :formatter lexic-format-shr :priority 1)
          ("Langenscheidt e-Grosswörterbuch Deutsch als Fremdsprache (Deu-Deu) (de-de)" :short "Langenscheidt" :formatter lexic-format-shr :priority 2))))
#+end_src
* email
#+begin_src scheme
"mu" "isync" "msmtp" "emacs-consult-mu" "oama" "cyrus-sasl-xoauth2"
#+end_src
#+begin_src scheme :noweb-ref guix-srv
(simple-service 'cyrus-vars home-environment-variables-service-type
  `(("SASL_PATH" . "$HOME/.guix-home/profile/lib/sasl2")))

(simple-service
 'goimapnotify
 home-shepherd-service-type
 (list
  (shepherd-service
   (provision '(goimapnotify))
   (requirement '(x11-display gpg-agent))
   (modules `(((shepherd support) #:hide (mkdir-p)) ;for '%user-log-dir'
              ,@(@ (gnu services shepherd) %default-modules)))
   (auto-start? #f)
   (start #~(make-forkexec-constructor
             (list #$(file-append (@ (gnu packages mail) goimapnotify) "/bin/goimapnotify"))
             #:log-file (string-append %user-log-dir "/goimapnotify.log")))
   (stop #~(make-kill-destructor)))))
#+end_src
#+begin_src sh :noweb-ref autostart :tangle no
"herd start goimapnotify"
#+end_src
#+begin_src elisp :tangle packages.el
(package! consult-mu :built-in t)
#+end_src
#+begin_src elisp
(use-package! consult-mu
  :after mu4e)
(use-package! consult-mu-contacts
  :after consult-mu)

(after! mu4e
  (defun mu4e~headers-quit-buffer ()
    "Quit the mu4e-headers buffer."
    (interactive)
    (mu4e-mark-handle-when-leaving)
    (quit-window t)
    ;; clear the decks before going to the main-view
    (mu4e--query-items-refresh 'reset-baseline))

  (map! :map mu4e-main-mode-map
        :n "q" #'bury-buffer
        :n "Q" #'mu4e-quit)
  (set-popup-rule! "^\\*mu4e-main\\*$" :ignore t)
  (set-popup-rule! "^\\*mu4e-headers\\*$" :ignore t)
  (setq mu4e-bookmarks '(("flag:unread and not maildir:/gmail/trash and not maildir:/gmail/sent" "unread" ?m))
        mu4e-modeline-support nil
        mu4e-sent-folder "/gmail/sent"
        mu4e-drafts-folder "/gmail/drafts"
        mu4e-trash-folder "/gmail/trash"
        mu4e-refile-folder "/gmail/all"
        sendmail-program "msmtp"
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from")
        send-mail-function #'sendmail-send-it
        message-send-mail-function #'message-send-mail-with-sendmail)

  (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . 8bit))

  (setq mu4e-contexts
        (cl-loop
         for email in '("sarg@sarg.org.ru" "de.strofimov@gmail.com")
         collect (make-mu4e-context
                  :name email
                  :vars `((user-mail-address . ,email)
                          (smtpmail-smtp-user . ,email))
                  :match-func
                  `(lambda (msg)
                     (when msg
                       (string-prefix-p ,email
                                        (mu4e-contact-email
                                         (nth 0
                                          (mu4e-message-field msg :to)))
                                        t)))))))
#+end_src
* browsing
#+begin_src elisp :tangle packages.el
(package! webpaste :built-in t)
(package! web-search :pin "a22cbdc663a1895d5a5b69de91e1e3b9eb64b92f")
(package! mpv :built-in t)
(package! yeetube :built-in t)
(package! qutebrowser :recipe
  (:host github :repo "lrustand/qutebrowser.el" :files (:defaults "*.py"))
  :pin "137f066dac06e1abdbf3285561ce2e1f3059b491")
#+end_src
#+begin_src scheme
"emacs-mpv" "emacs-webpaste" "emacs-yeetube"
#+END_src
#+begin_src elisp
(defun browse-url-qute-private (url &rest _)
  "Make qutebrowser open URL in private-browsing window."
  (interactive (browse-url-interactive-arg "URL: "))
  (let ((process-environment (browse-url-process-environment)))
    (start-process "qutebrowser-private" nil
           "qutebrowser" "--target" "private-window" url)))

(use-package! mpv
  :commands mpv-play-url
  :custom
  (mpv-default-options '("--force-window=immediate")))

(defun browse-url-mpv (url &rest _)
  (mpv-play-url url))

(defun browse-url-emms (url &rest _)
  (emms-add-url url))

(setq browse-url-handlers
      `((,(rx string-start "https://" (opt "www.") "youtu" (opt ".") "be") . browse-url-mpv)
        ("https://t.me/" . telega-browse-url)
        ("open.spotify.com" . browse-url-emms)
        ,@browse-url-handlers))

(setq-default
 browse-url-browser-function 'browse-url-generic
 browse-url-generic-program "qutebrowser")

(use-package! web-search
  :commands web-search
  :custom
  (web-search-default-provider "DuckDuckGo"))

(def-modeline! :qutebrowser
               '("" evil-mode-line-tag "%b") `(""))

(set-modeline-hook! 'qutebrowser-exwm-mode-hook :qutebrowser)

(use-package! qutebrowser
  :hook ((exwm-init . global-qutebrowser-exwm-mode)
         (exwm-init . qutebrowser-evil-state-mode)
         (exwm-init . qutebrowser-theme-export-mode))
  :custom
  (qutebrowser-pass-username-function (lambda (e) (auth-source-pass-get "login" e)))
  (qutebrowser-launcher-backend #'qutebrowser-consult-launcher))

(use-package! yeetube
  :config
  (map! :map yeetube-mode-map :ni "RET" #'yeetube-play))
#+end_src
* shell
#+begin_src elisp :tangle packages.el
(package! eat :built-in t)
(package! detached :built-in t)
#+end_src

#+begin_src scheme
"emacs-eat" "emacs-detached" "direnv"
#+end_src

#+begin_src scheme :noweb-ref guix-srv
(simple-service 'direnv-bash-hook home-bash-service-type
 (home-bash-extension
  (bashrc (list
           (plain-file "envrc-hook"
            "eval \"$(direnv hook bash)\"")))))
#+end_src

#+begin_src scheme :noweb-ref guix-srv
(simple-service 'eat-bash-integration home-bash-service-type
 (home-bash-extension
  (bashrc (list
           (plain-file "eat"
            "[ -n \"$EAT_SHELL_INTEGRATION_DIR\" ] && source \"$EAT_SHELL_INTEGRATION_DIR/bash\"")))))
#+end_src

#+begin_src elisp
; presumably speeds up I/O
; https://debbugs.gnu.org/cgi/bugreport.cgi?bug=44007
(setq process-adaptive-read-buffering nil)
(setq read-process-output-max (* 4 1024 1024))

(after! eshell
  (setq! eshell-prefer-lisp-functions 't)
  (set-eshell-alias!
   "doom" "$doom-core-dir/../bin/doom $@*"
   "guix" "*guix $@*")
  (add-to-list 'eshell-modules-list 'eshell-smart)
  (map! :map eshell-mode-map
        :ni "C-r" #'consult-history))

(use-package! eat
  :hook ((eshell-load . eat-eshell-mode)
         (eshell-load . eat-eshell-visual-command-mode)))

(use-package! detached
  :config
  (detached-init)
  :bind (;; Replace `async-shell-command' with `detached-shell-command'
         ([remap async-shell-command] . detached-shell-command)
         ;; Replace `compile' with `detached-compile'
         ([remap compile] . detached-compile)
         ([remap recompile] . detached-compile-recompile)
         ;; Replace built in completion of sessions with `consult'
         ([remap detached-open-session] . detached-consult-session))
  :custom ((detached-show-output-on-attach t)
           (detached-terminal-data-command system-type)))
#+end_src

* dired
#+begin_src elisp :tangle packages.el
(package! dired-du :built-in t)
(package! openwith :built-in t)
(package! sxiv :built-in t)
#+end_src

#+begin_src scheme
"emacs-dired-hacks" "emacs-dired-du"
"emacs-openwith" "emacs-sxiv"
#+end_src

#+begin_src elisp
(after! dirvish
  (setq dired-omit-files
        (concat dired-omit-files "\\|^\\..*$"))

  (add-to-list 'dirvish-hide-details 'dired)
  (setq! dirvish-quick-access-entries
         `(("h" "~/"                          "Home")
           ("c" ,(f-dirname doom-core-dir)    "Doom root")
           ("e" "~/.dotfiles/emacs/.doom.d"   "Emacs config")
           ("d" "~/Downloads/"                "Downloads")
           ("m" "/media/500GB/media"          "Media"))))

(use-package! sxiv)
(use-package! dired-du
  :custom
  ;; human readable
  (dired-du-size-format 't))

(after! async
  (dired-async-mode 1))

(defun openwith-has-association (file)
  (-any? (lambda (oa) (string-match (car oa) file)) openwith-associations))

(use-package! openwith
  :hook (after-init . openwith-mode)
  :custom
  (openwith-associations
   '(("\\.\\(?:pdf\\|epub\\|djvu\\|mkv\\|webm\\|avi\\|mp4\\)\\'" "xdg-open" (file))))

  :config
  ;; Don't ask if file is too large when it'll be handled by openwith-mode.
  (advice-add 'abort-if-file-too-large :before-until
              (lambda (size op-type filename &rest args)
                (and (boundp 'openwith-mode) openwith-mode
                     (openwith-has-association filename)))))
#+end_src

* bindings
#+begin_src elisp
(map!
 "C-x b" #'bufler-switch-buffer

 (:map dired-mode-map
  :n (kbd "DEL") #'dired-up-directory
  :n "K" #'dired-do-kill-lines)

 (:map image-mode-map
  :n "q" #'kill-current-buffer)

 :leader
 "h" nil
 "," #'bufler-switch-buffer
 :desc "Music" "oM" #'=emms
 :desc "Dash" "om" #'dash-menu)
#+end_src
* llm
#+begin_src elisp
(after! gptel
  (setq gptel-model 'gemini-2.0-flash
        gptel-backend
        (gptel-make-gemini "Gemini"
          :key (lambda (&rest args)
                 (gptel-api-key-from-auth-source "google.com" "gemini"))
          :stream t)))
#+end_src
* experimental
** bookmark
#+begin_src scheme
"emacs-bookmark-plus"
#+end_src
#+begin_src elisp :tangle packages.el
(package! bookmark+ :built-in t)
#+end_src
#+begin_src elisp
(setq bookmark-default-file "/storage/data/emacs/bookmarks")
(use-package! bookmark+)
#+end_src
** cyclekey
#+begin_src elisp :tangle packages.el
(package! cyclekey :recipe (:host github :repo "shankar2k/cyclekey")
  :pin "6f2b5863ab545a68775376825e5a4361a5413a62")
#+end_src
#+begin_src elisp
(use-package! cyclekey
  :bind ("M-o" . cyclekey-cycle)

  :config
  (cyclekey-add-language "German")
  (cyclekey-init))
#+end_src
** magic sqlite
#+begin_src elisp
; https://christiantietze.de/posts/2024/01/emacs-sqlite-mode-open-sqlite-files-automatically/
(use-package sqlite-mode
  :config
  (defun ct/sqlite-view-file-magically ()
    "Runs `sqlite-mode-open-file' on the file name visited by the
current buffer, killing it."
    (require 'sqlite-mode)
    (let ((file-name buffer-file-name))
      (kill-current-buffer)
      (sqlite-mode-open-file file-name)))

  (add-to-list 'magic-mode-alist '("SQLite format 3\x00" . ct/sqlite-view-file-magically)))
#+end_src
** gpx-mode
#+begin_src scheme
;; "emacs-gpx"
"emacs-osm"
#+end_src
#+begin_src elisp
(use-package! osm
  :init
  (set-popup-rule! "^\\*osm" :ignore t)

  :config
  (defun gpx-show-map-osm (file track segment)
    (osm-gpx-show file)))

;; (use-package! gpx
;;   :config
;;   (setq gpx-show-map-function  #'gpx-show-map-osm))
#+end_src
** qute-dired
#+begin_src elisp
(defun qute/choose-file ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (with-temp-file qute-filename
      (insert (s-join "\n" files)))
    (unbind-key "C-C C-c" 'dired-mode-map)
    (+dired/quit-all)))

(defun qute/dired-hook (&optional _)
  (when (s-starts-with? "/tmp/qutebrowser-fileselect" buffer-file-name)
    (setq qute-filename buffer-file-name)
    (kill-buffer)
    (dired "~/")
    (bind-key "C-c C-c" #'qute/choose-file 'dired-mode-map)))

(add-hook! 'server-visit-hook #'qute/dired-hook)
#+end_src

** emacs-dmenu
#+begin_src elisp
(cl-defun dmenu/select-line-from-file (file &key prompt lines category)
  "completing-read a line from FILE."
  (consult--read
   (with-temp-buffer
     (insert-file-contents file)
     (string-lines (buffer-string)))
   :prompt (concat (or prompt "Select") ": ")
   :category category
   :require-match t))
#+end_src

#+begin_src sh :tangle ~/.local/bin/dmenu :shebang #!/usr/bin/env bash
usage() {
  echo "Usage: $0 -p prompt -l lines -c category"
  exit 1
}

prompt=nil
lines=nil
category=nil
while getopts ":p:l:c:" opt; do
  case $opt in
    p) prompt="\"$OPTARG\""
    ;;
    l) lines="$OPTARG"
    ;;
    c) category="'$OPTARG"
    ;;
    ,*) usage
    ;;
  esac
done

if [ "$prompt" == "nil" ] && [ "$lines" == "nil" ]; then
  usage
fi

tmp=$(mktemp); cat > $tmp
emacsclient -e '(dmenu/select-line-from-file "'$tmp'" :prompt '"$prompt"' :lines '$lines' :category '$category')' | jq -r .
#+end_src
** org-node
#+begin_src scheme
"emacs-org-node"
#+end_src
#+begin_src elisp :tangle packages.el
(package! org-node :built-in t)
#+end_src
#+begin_src elisp
(use-package! org-node)
#+end_src
** org-supertag
#+begin_src elisp :tangle packages.el
(package! org-supertag
  :recipe (:host github
           :repo "yibie/org-supertag"
           :files (:defaults (:exclude "*sim*"))))
#+end_src
#+begin_src elisp
(use-package! org-supertag
  :disabled
  :after org
  :config
  (org-supertag-setup))
#+end_src
* TODO todo [7/12]
** DONE console font
** DONE mingetty with xorg autostart (under sarg), put `lock.sh` first in the .xsession
** DONE user syncthing
** DONE check if greetd is necessary
** TODO move away from org-contacts
Reqs:
- use [[https://datatracker.ietf.org/doc/html/rfc6350#section-5.4][ALTID]] for names in russian/english
- export contacts with UID to avoid duplication
- group KIND
- embed photo
- nickname
- impp for telega/whatsapp
https://isamert.net/2021/04/21/managing-your-contacts-in-org-mode-and-syncing-them-to-your-phone-android-ios-whatever-.html

** DONE guix gc, but not that aggressive
=--gc-keep-derivations= and =--gc-keep-outputs= to =guix-daemon= params
** NO Fix hardcoded =Guix_image= root partition name
** TODO Fix =gnupg= symlink\\
=guix home= =update-symlinks= creates =~/.gnupg= before my symlink activation service runs
therefore gnupg private keys are not symlinked\\
Target state:
*** =~/.gnupg= is a symlink to =/storage/data/gnupg=
*** =gpg-agent.conf= and =gpg.conf= are managed by =guix home=
** DONE +duplicate env entries because of ~doom env~+ (just delete the file)
** TODO counsel-spotify pollutes namespace because of :reader in EIEIO objects (name, artist ...)
** TODO emacs keybindings revamp
- winner to be replaced with custom window management
- evil bindings in EMMS buffers (q to close, SPC to enter)
- repeat Super+<digit> to switch (saved) window configurations
** TODO how to make home services depend on online status?
* archive :noexport:
** emacs-one-frame
#+begin_src sh :tangle no :shebang #!/bin/bash
# https://taingram.org/2017/05/09/using-emacsclient-to-speed-up-editing/
# if no args open new frame
if [ $# -eq 0 ]; then
    emacsclient -c -n
    exit
fi

emacsclient -e "(frames-on-display-list \"$DISPLAY\")" &>/dev/null

if [ $? -eq 0 ]; then
    emacsclient -n "$*"
else
    emacsclient -c -n "$*"
fi
#+end_src
** openscad
#+begin_src elisp :tangle no
(defun openscad-preview ()
  (interactive)
  (select-window (split-window-right))
  (start-process "openscad" nil "openscad" (buffer-file-name)))
#+end_src

** selfcontrol
#+begin_src elisp :tangle no
(defun sarg/ad-selfcontrol-time-restriction (orig-fun &rest args)
  (if (or (= 0 (mod
                (calendar-day-of-week (calendar-current-date))
                6)) ; 0 and 6 - Sunday and Saturday
          (> (nth 2 (decode-time)) 18))
      (apply orig-fun args)
    (message "It's not the time yet!")))

(defun sarg/ad-selfcontrol-otp-confirm (proc &rest args)
  "Asks to enter random string as confirmation before executing PROC."
  (interactive)
  (let* ((pass (format "%06x%06x%06x"
                       (random (expt 16 6))
                       (random (expt 16 6))
                       (random (expt 16 6))))

         (input (read-string (format "Enter %s if you wish to proceed: " pass))))

    (if (string= input pass)
        (apply proc args))))

(after! elfeed
  (advice-add 'elfeed-update :around #'sarg/ad-selfcontrol-otp-confirm)
  (advice-add '=rss :around #'sarg/ad-selfcontrol-otp-confirm)
  (advice-add 'elfeed-update :around #'sarg/selfcontrol-time-restriction))

(after! telega
  (advice-add 'ivy-telega-chat-with :around #'sarg/ad-selfcontrol-otp-confirm))
#+end_src

** fate
#+begin_src elisp :tangle no
(use-package! fate
  :disabled
  :load-path "~/devel/ext/fate"
  :config
  (setq fate:data-file "~/.events/win")

  (defun fate:buffer-string (buffer)
    "Return either path or name of BUFFER."
    (or (buffer-file-name buffer)
        (buffer-name buffer)))

  (defun fate:log-state (state)
    "Write STATE to the database file."
    (write-region state nil fate:data-file 'append :inhibit))

  (defun fate:state-string-base (left right)
    "Represent state using LEFT and RIGHT."
    (format "%s;win;%s;%s\n"
            (format-time-string "%s.%6N")
            (fate:escape left)
            (fate:escape right))))
#+end_src
